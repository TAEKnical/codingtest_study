
# 시뮬레이션 연습

## 1. 배열의 90도 회전


# 배열의 90도 회전이란 무엇인가?

## 1. 배열의 개념
배열은 여러 개의 요소들이 행과 열로 구성된 이차원 구조입니다. 각 요소는 특정한 위치를 가지며, 이 위치는 행(row)과 열(column)로 정의됩니다.

예를 들어, 다음과 같은 배열이 있다고 가정해봅시다:

```
1  2  3
4  5  6
7  8  9
```

여기서, 숫자 1, 2, 3, 4, 5, 6, 7, 8, 9가 각각 배열의 요소들입니다. 이 배열은 3x3 구조로, 3개의 행과 3개의 열로 구성되어 있습니다.

## 2. 90도 회전의 정의
배열의 90도 회전은 배열의 모든 요소를 시계 방향으로 90도 돌리는 과정을 의미합니다. 이 과정에서 배열의 행은 열로, 열은 행으로 변환됩니다.

이제 이 배열을 90도 회전해보겠습니다. 아래 설명을 따라오세요.

## 3. 배열의 90도 회전 과정
배열의 각 요소를 새로운 위치로 이동시키는 것이 90도 회전의 핵심입니다. 각 요소는 새로운 위치에 정확하게 배치되어야 합니다.

먼저, 배열을 다시 살펴보겠습니다:

```
1  2  3
4  5  6
7  8  9
```

이 배열에서:

- **1**은 왼쪽 위에 위치합니다. 이 요소는 오른쪽 위로 이동하게 됩니다.
- **2**는 첫 번째 행의 가운데에 위치합니다. 이 요소는 오른쪽 중앙으로 이동합니다.
- **3**은 오른쪽 위에 위치합니다. 이 요소는 오른쪽 아래로 이동합니다.
- **4**는 왼쪽 중앙에 위치합니다. 이 요소는 중앙 왼쪽으로 이동합니다.
- **5**는 배열의 중심에 위치합니다. 이 요소는 위치를 변경하지 않습니다.
- **6**은 오른쪽 중앙에 위치합니다. 이 요소는 중앙 오른쪽으로 이동합니다.
- **7**은 왼쪽 아래에 위치합니다. 이 요소는 왼쪽 위로 이동합니다.
- **8**은 아래쪽 중앙에 위치합니다. 이 요소는 왼쪽 중앙으로 이동합니다.
- **9**는 오른쪽 아래에 위치합니다. 이 요소는 왼쪽 아래로 이동합니다.

이 과정을 통해 배열은 다음과 같이 변경됩니다:

```
7  4  1
8  5  2
9  6  3
```

이와 같이 배열의 모든 요소가 새로운 위치로 이동하게 됩니다.

## 4. 또 다른 예시
다른 배열을 예로 들어 보겠습니다:

```
a  b
c  d
```

이 배열의 90도 회전 과정은 다음과 같습니다:

- **a**는 왼쪽 위에 위치하므로 오른쪽 위로 이동합니다.
- **b**는 오른쪽 위에 위치하므로 오른쪽 아래로 이동합니다.
- **c**는 왼쪽 아래에 위치하므로 왼쪽 위로 이동합니다.
- **d**는 오른쪽 아래에 위치하므로 왼쪽 아래로 이동합니다.

결과적으로 배열은 다음과 같이 변경됩니다:

```
c  a
d  b
```

이처럼 배열의 요소들이 시계 방향으로 90도 회전하여 새로운 배열을 형성합니다.

## 5. 추가적인 정보
배열을 90도로 회전하면 새로운 배열이 생성되며, 이를 두 번 반복하면 180도 회전, 세 번 반복하면 270도 회전, 네 번 반복하면 다시 원래 배열로 돌아옵니다. 이러한 개념을 통해 배열의 회전을 이해할 수 있습니다.

배열의 회전은 다양한 알고리즘과 데이터 처리 과정에서 유용하게 사용될 수 있습니다.


<details>
<summary>실전 문제</summary>


# 문제: 3x3 행렬 90도 회전

3x3 정수 행렬이 주어졌을 때, 이 행렬을 시계 방향으로 90도 회전시키는 프로그램을 작성하세요. 아래 주어진 코드를 완성하여 이 기능을 구현하세요.

## 주어진 코드

c
#include <stdio.h>

void rotate90(int arr[3][3]); // 배열을 90도로 회전하는 함수 (문제에선 3x3 한정)
void print(int* arr[3][3]); // 배열을 출력하는 함수 (문제에선 3x3 한정)

int matrix[3][3] = 
{
  {1, 2, 3},
  {4, 5, 6},
  {7, 8, 9}
};

int main()
{
    rotate90(matrix); // 행렬을 90도 회전시키는 함수 호출
    print(matrix);    // 회전된 행렬을 출력하는 함수 호출
    
    return 0;     
}


## 구현해야 할 함수

1. **rotate90 함수**
   - **기능**: 3x3 행렬을 시계 방향으로 90도 회전시킵니다.
   - **입력**: 3x3 행렬의 시작 주소를 가리키는 포인터.
   - **반환**: 없음. 입력된 행렬 자체를 수정하여 회전된 결과를 반영합니다.

2. **print 함수**
   - **기능**: 3x3 행렬을 출력합니다.
   - **입력**: 3x3 행렬의 시작 주소를 가리키는 포인터.
   - **반환**: 없음. 행렬의 각 요소를 출력합니다.

## 요구사항

1. rotate90 함수를 작성하여 3x3 행렬을 시계방향으로 90도 회전시키세요. 
    - 이 함수는 매개변수로 주어진 3x3 행렬을 수정하여, 원래의 행렬을 시계 방향으로 90도 회전한 결과로 만듭니다.
2. print 함수를 작성하여 3x3 행렬을 출력하세요.
    - 이 함수는 3x3 행렬을 매개변수로 받아 행과 열을 구분하여 출력해야 합니다.
  
</details>

<details>
<summary>해설</summary>

# 문제: 3x3 행렬 90도 회전 - 정답 및 해설

## 정답 코드

다음은 주석을 추가하여 이해하기 쉽게 만든 정답 코드입니다:

c
#include <stdio.h>

// 3x3 배열을 시계 방향으로 90도 회전시키는 함수
void rotate90(int arr[3][3]) {
    int temp; // 임시 변수로 값을 저장
    // 행렬의 4개 모서리 요소를 교환하여 회전시키는 과정
    for (int i = 0; i < 2; i++) { // 첫 번째 루프: 행렬의 왼쪽 상단부터 시작
        for (int j = i; j < 2 - i; j++) { // 두 번째 루프: 행렬의 해당 열을 따라 이동
            // 사각형의 4개의 요소를 시계 방향으로 한 칸씩 이동
            temp = arr[i][j]; // 첫 번째 요소를 임시 변수에 저장
            arr[i][j] = arr[2-j][i]; // 네 번째 요소를 첫 번째 요소로 이동
            arr[2-j][i] = arr[2-i][2-j]; // 세 번째 요소를 네 번째 요소로 이동
            arr[2-i][2-j] = arr[j][2-i]; // 두 번째 요소를 세 번째 요소로 이동
            arr[j][2-i] = temp; // 임시 변수에 저장된 첫 번째 요소를 두 번째 요소로 이동
        }
    }
}

// 3x3 배열을 출력하는 함수
void print(int arr[3][3]) {
    // 행렬의 각 요소를 출력
    for(int i = 0; i < 3; i++) { // 첫 번째 루프: 행렬의 각 행을 따라 이동
        for(int j = 0; j < 3; j++) { // 두 번째 루프: 행렬의 각 열을 따라 이동
            printf("%d ", arr[i][j]); // 현재 요소를 출력
        }
        printf("\n"); // 행이 끝날 때 줄 바꿈
    }
}

int matrix[3][3] = 
{
  {1, 2, 3},
  {4, 5, 6},
  {7, 8, 9}
};

int main() {
    rotate90(matrix); // 행렬을 90도 회전시키는 함수 호출
    print(matrix);    // 회전된 행렬을 출력하는 함수 호출
    
    return 0;     
}

  
</details>

## 2. 달팽이 수열


# 달팽이 수열이란 무엇인가?

## 1. 달팽이 수열의 개념
달팽이 수열은 2차원 배열을 채우는 방법 중 하나로, 배열의 가장자리를 따라 시계 방향으로 나선형으로 숫자를 채워 넣는 방식입니다. 이 방법을 통해 배열의 모든 요소를 일정한 순서로 채울 수 있습니다.

예를 들어, 3x3 배열이 있다고 가정해봅시다. 이 배열을 달팽이 수열로 채우면 다음과 같이 됩니다:

### 초기 3x3 배열

|   |   |   |
|---|---|---|
|   |   |   |
|   |   |   |
|   |   |   |

### 달팽이 수열로 채워진 3x3 배열

|  1  |  2  |  3  |
|---|---|---|
|  8  |  9  |  4  |
|  7  |  6  |  5  |

숫자가 배열의 가장자리부터 시작하여 시계 방향으로 나선형으로 채워진 것을 볼 수 있습니다.

## 2. 달팽이 수열을 구현하는 방법
달팽이 수열을 구현하기 위해서는 다음 단계를 따라야 합니다:

### 2.1. 첫 번째 단계: 왼쪽에서 오른쪽으로 이동
먼저, 배열의 첫 번째 행에서 왼쪽에서 오른쪽으로 숫자를 채웁니다. 이 단계에서는 배열의 가장 위쪽 행에 숫자를 채워넣습니다.

### 2.2. 두 번째 단계: 위에서 아래로 이동
첫 번째 행을 채운 후, 배열의 오른쪽 열을 따라 위에서 아래로 숫자를 채웁니다. 이 과정에서는 마지막 열의 요소들이 채워집니다.

### 2.3. 세 번째 단계: 오른쪽에서 왼쪽으로 이동
다음으로, 배열의 아래쪽 행을 오른쪽에서 왼쪽으로 채웁니다. 이 단계에서는 가장 아래쪽 행의 숫자들이 채워집니다.

### 2.4. 네 번째 단계: 아래에서 위로 이동
마지막으로, 배열의 왼쪽 열을 따라 아래에서 위로 숫자를 채웁니다. 이 과정에서 첫 번째 열의 요소들이 채워집니다.

### 2.5. 반복
이 과정을 배열이 완전히 채워질 때까지 반복합니다. 배열이 채워질수록 나선형 모양이 점점 중심으로 수렴하게 됩니다.

## 3. 예시
예를 들어, 4x4 배열이 있다고 가정하면, 달팽이 수열로 배열을 채우는 과정은 다음과 같습니다:

### 초기 4x4 배열

|   |   |   |   |
|---|---|---|---|
|   |   |   |   |
|   |   |   |   |
|   |   |   |   |
|   |   |   |   |

### 달팽이 수열로 채워진 4x4 배열

|  1  |  2  |  3  |  4  |
|---|---|---|---|
|  12  |  13  |  14  |  5  |
|  11  |  16  |  15  |  6  |
|  10  |  9  |  8  |  7  |

이 배열에서 숫자는 시계 방향으로 나선형으로 채워져 있으며, 배열의 모든 요소가 정확하게 순서대로 채워진 것을 볼 수 있습니다.

## 4. 달팽이 수열의 응용
달팽이 수열은 다양한 문제 해결에 사용될 수 있습니다. 예를 들어, 행렬의 데이터를 특정한 순서로 처리해야 하는 경우나, 그래픽스에서 나선형 패턴을 생성할 때 유용합니다. 알고리즘 구현의 연습으로도 자주 사용됩니다.

이제 달팽이 수열에 대해 충분히 이해했을 것입니다. 이를 다양한 상황에 응용해보세요.




<details>
<summary>실전 문제</summary>

# 문제: 달팽이 수열 생성

정수 n이 주어질 때, 1부터 n^2까지의 수를 달팽이 모양으로 배치한 n x n 행렬을 생성하는 프로그램을 작성하세요. 아래 주어진 코드를 완성하여 이 기능을 구현하세요.

## 주어진 코드

```c
#include <stdio.h>

void generateSnailArray(int n, int arr[n][n]); // 달팽이 수열을 생성하는 함수
void printArray(int n, int arr[n][n]); // 배열을 출력하는 함수

int main()
{
    int n = 4; // 예시로 4x4 달팽이 수열을 생성
    int arr[n][n];
    
    generateSnailArray(n, arr); // 달팽이 수열을 생성하는 함수 호출
    printArray(n, arr);         // 생성된 수열을 출력하는 함수 호출
    
    return 0;     
}
```

## 구현해야 할 함수

1. **generateSnailArray 함수**
   - **기능**: 1부터 n^2까지의 수를 달팽이 모양으로 배치한 n x n 행렬을 생성합니다.
   - **입력**: n과 n x n 배열의 시작 주소를 가리키는 포인터.
   - **반환**: 없음. 입력된 배열 자체를 수정하여 달팽이 수열을 반영합니다.

2. **printArray 함수**
   - **기능**: n x n 행렬을 출력합니다.
   - **입력**: n과 n x n 배열의 시작 주소를 가리키는 포인터.
   - **반환**: 없음. 행렬의 각 요소를 출력합니다.

## 요구사항

1. `generateSnailArray` 함수를 작성하여 n x n 행렬을 달팽이 모양으로 채우세요. 
    - 이 함수는 매개변수로 주어진 n과 배열을 사용하여, 1부터 n^2까지의 수를 시계 방향으로 돌며 달팽이 형태로 채웁니다.
2. `printArray` 함수를 작성하여 n x n 행렬을 출력하세요.
    - 이 함수는 n x n 행렬을 매개변수로 받아 행과 열을 구분하여 출력해야 합니다.

</details>

<details>
<summary>해설</summary>

# 문제: 달팽이 수열 생성 - 정답 및 해설 (주석 추가 버전)

## 정답 코드

다음은 주석을 추가하여 이해하기 쉽게 만든 정답 코드입니다:

```c
#include <stdio.h>

// n x n 달팽이 수열을 생성하는 함수
void generateSnailArray(int n, int arr[n][n]) {
    int value = 1;
    int min_row = 0, max_row = n-1;
    int min_col = 0, max_col = n-1;
    
    while (value <= n * n) {
        for (int i = min_col; i <= max_col && value <= n * n; i++) {
            arr[min_row][i] = value++;
        }
        min_row++;
        
        for (int i = min_row; i <= max_row && value <= n * n; i++) {
            arr[i][max_col] = value++;
        }
        max_col--;
        
        for (int i = max_col; i >= min_col && value <= n * n; i--) {
            arr[max_row][i] = value++;
        }
        max_row--;
        
        for (int i = max_row; i >= min_row && value <= n * n; i--) {
            arr[i][min_col] = value++;
        }
        min_col++;
    }
}

// n x n 배열을 출력하는 함수
void printArray(int n, int arr[n][n]) {
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
}

int main() {
    int n = 4; // 예시로 4x4 달팽이 수열을 생성
    int arr[n][n];
    
    generateSnailArray(n, arr); // 달팽이 수열을 생성하는 함수 호출
    printArray(n, arr);         // 생성된 수열을 출력하는 함수 호출
    
    return 0;     
}
```

</details>

## 3. 배열을 2차원 좌표로 해서 상하좌우 이동

## 1. 기본 개념
2차원 배열에서 상하좌우로 이동하는 것은, 특정 좌표에서 상, 하, 좌, 우의 인접한 요소로 이동하는 것을 의미합니다. 이러한 이동은 탐색 알고리즘이나 게임 개발에서 매우 중요한 역할을 합니다.

예를 들어, 2차원 배열에서 현재 위치가 중앙에 있다고 가정해봅시다. 이 위치에서 상하좌우로 이동하는 것은 인접한 요소로 움직이는 것을 의미합니다.

## 2. 좌표 변화 이해하기
2차원 배열에서 특정 위치에서 상하좌우로 이동하려면, 각 방향에 대해 좌표가 어떻게 변하는지를 알아야 합니다.

- **상**: 위쪽으로 이동하는 것은 행 번호를 감소시키는 것을 의미합니다. 즉, 현재 위치에서 `row - 1, col`로 이동합니다.
- **하**: 아래쪽으로 이동하는 것은 행 번호를 증가시키는 것을 의미합니다. 즉, 현재 위치에서 `row + 1, col`로 이동합니다.
- **좌**: 왼쪽으로 이동하는 것은 열 번호를 감소시키는 것을 의미합니다. 즉, 현재 위치에서 `row, col - 1`로 이동합니다.
- **우**: 오른쪽으로 이동하는 것은 열 번호를 증가시키는 것을 의미합니다. 즉, 현재 위치에서 `row, col + 1`로 이동합니다.

## 3. 예시
다음은 3x3 배열에서 중앙 위치(1, 1)에서 상하좌우로 이동하는 예시입니다:

### 초기 3x3 배열

|   |   |   |
|---|---|---|
|  1  |  2  |  3  |
|  4  |  5  |  6  |
|  7  |  8  |  9  |

여기서, `5`가 위치한 좌표는 (1, 1)입니다. 이 위치에서 상하좌우로 이동하면 다음과 같이 됩니다:

- **상**: (0, 1) → 값 `2`
- **하**: (2, 1) → 값 `8`
- **좌**: (1, 0) → 값 `4`
- **우**: (1, 2) → 값 `6`

이동 후의 각 위치에서의 값을 살펴보면 다음과 같습니다:

### 상하좌우 이동 후의 위치와 값

| 방향 | 이동 후 좌표 | 해당 위치의 값 |
|---|---|---|
| 상 | (0, 1) | 2 |
| 하 | (2, 1) | 8 |
| 좌 | (1, 0) | 4 |
| 우 | (1, 2) | 6 |

## 4. 적용 및 응용
2차원 배열에서의 상하좌우 이동은 다양한 알고리즘에서 활용될 수 있습니다. 예를 들어, 미로 탐색, 그래프 탐색, 또는 게임에서의 캐릭터 이동 등이 있습니다. 이러한 이동은 배열의 경계를 넘어가지 않도록 주의해야 하며, 배열의 크기와 형태에 맞게 적용해야 합니다.

이제 2차원 배열에서 상하좌우로 이동하는 개념에 대해 충분히 이해했을 것입니다. 이를 바탕으로 다양한 문제를 해결할 수 있을 것입니다.

이동할 때 배열의 경계를 넘어가는지 확인하는 것이 중요합니다.


<details>
<summary>실전 문제</summary>

# 문제: 2D 배열에서 상하좌우 이동

n x n 크기의 2D 정수 배열과 시작 좌표가 주어질 때, 상하좌우로 이동하여 특정 경로를 따라 이동하는 프로그램을 작성하세요. 

## 이동 경로 설명

이동 경로는 문자열로 주어지며, 각 문자는 이동 방향을 나타냅니다:

- `U`는 위쪽(Up)으로 한 칸 이동
- `D`는 아래쪽(Down)으로 한 칸 이동
- `L`는 왼쪽(Left)으로 한 칸 이동
- `R`는 오른쪽(Right)으로 한 칸 이동

예를 들어, 주어진 경로 문자열이 `UURDDL`이라면:
1. 시작 위치에서 위로 두 칸 이동 (`UU`)
2. 오른쪽으로 한 칸 이동 (`R`)
3. 아래로 두 칸 이동 (`DD`)
4. 마지막으로 왼쪽으로 한 칸 이동 (`L`)

## 주어진 코드

```c
#include <stdio.h>

void moveIn2DArray(int n, int arr[n][n], int start_x, int start_y, char* moves); // 상하좌우 이동을 수행하는 함수
void printArray(int n, int arr[n][n]); // 배열을 출력하는 함수

int main()
{
    int n = 5; // 예시로 5x5 배열을 생성
    int arr[5][5] = {0}; // 초기 배열은 0으로 채움
    int start_x = 2, start_y = 2; // 시작 좌표를 배열의 중앙으로 설정
    char moves[] = "UURDDL"; // 예시 이동 경로: 위, 위, 오른쪽, 아래, 아래, 왼쪽
    
    moveIn2DArray(n, arr, start_x, start_y, moves); // 이동을 수행하는 함수 호출
    printArray(n, arr); // 이동 후의 배열을 출력하는 함수 호출
    
    return 0;     
}
```

## 구현해야 할 함수

1. **moveIn2DArray 함수**
   - **기능**: 주어진 시작 좌표에서 상하좌우 이동을 수행하여 배열을 업데이트합니다.
   - **입력**: n과 n x n 배열, 시작 좌표 (start_x, start_y), 이동 경로를 나타내는 문자열 moves.
   - **반환**: 없음. 입력된 배열 자체를 수정하여 이동 경로를 반영합니다.

2. **printArray 함수**
   - **기능**: n x n 배열을 출력합니다.
   - **입력**: n과 n x n 배열.
   - **반환**: 없음. 배열의 각 요소를 출력합니다.

## 요구사항

1. `moveIn2DArray` 함수를 작성하여 상하좌우 이동을 수행하세요.
    - 이 함수는 주어진 시작 좌표에서 상(U), 하(D), 좌(L), 우(R)로 이동합니다. 이동한 위치에 1을 기록합니다.
    - 배열의 경계를 넘어가는 경우, 해당 이동은 무시합니다.
2. `printArray` 함수를 작성하여 n x n 배열을 출력하세요.
    - 이 함수는 n x n 배열을 매개변수로 받아 행과 열을 구분하여 출력해야 합니다.

</details>

<details>
<summary>해설</summary>

# 문제: 2D 배열에서 상하좌우 이동 - 정답 및 해설

## 정답 코드

다음은 주석을 추가하여 이해하기 쉽게 만든 정답 코드입니다:

```c
#include <stdio.h>

// 상하좌우 이동을 수행하는 함수
void moveIn2DArray(int n, int arr[n][n], int start_x, int start_y, char* moves) {
    int x = start_x;
    int y = start_y;
    
    arr[x][y] = 1; // 시작 위치에 1을 기록
    
    for (int i = 0; moves[i] != '\0'; i++) {
        if (moves[i] == 'U' && x > 0) x--; // 위로 이동
        else if (moves[i] == 'D' && x < n-1) x++; // 아래로 이동
        else if (moves[i] == 'L' && y > 0) y--; // 왼쪽으로 이동
        else if (moves[i] == 'R' && y < n-1) y++; // 오른쪽으로 이동
        
        arr[x][y] = 1; // 이동한 위치에 1을 기록
    }
}

// n x n 배열을 출력하는 함수
void printArray(int n, int arr[n][n]) {
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
}

int main() {
    int n = 5; // 예시로 5x5 배열을 생성
    int arr[5][5] = {0}; // 초기 배열은 0으로 채움
    int start_x = 2, start_y = 2; // 시작 좌표를 배열의 중앙으로 설정
    char moves[] = "UURDDL"; // 예시 이동 경로: 위, 위, 오른쪽, 아래, 아래, 왼쪽
    
    moveIn2DArray(n, arr, start_x, start_y, moves); // 이동을 수행하는 함수 호출
    printArray(n, arr); // 이동 후의 배열을 출력하는 함수 호출
    
    return 0;     
}
```

</details>

