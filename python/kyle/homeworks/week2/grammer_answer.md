
## 1. 리스트의 기본 개념
- 뮤터블 객체
- 값에 순서가 있고 중복을 허용함
- 순서가 있으므로 인덱싱, 슬라이싱이 가능하다는 점에서는 튜플과 유사하나 값의 수정이 가능함
- 값의 순서가 중요하면서도 동적으로 값을 조정하거나, 값의 변화가 잦은 집합을 다룰 때 적합
 
## 2. 리스트의 효율성
- 리스트의 임의 접근의 시간 복잡도는 무엇인가요?
	- O(1).
- 리스트의 맨 앞이나 중간에 데이터를 삽입할 때 시간 복잡도가 어떻게 달라지는지 설명해주세요.
	- 맨 앞에 삽입하는 경우 나머지 모든 요소를 한 칸씩 뒤로 이동시켜야 하므로 총 n+1회의 연산이 발생함
	- 따라서 O(n)
	- 그 외에도 아래와 같은 케이스를 고려할 수 있음
		- **O(1)**: 특정 인덱스 접근, 끝에 요소 추가 - 위치 특정이 가능하며 다른 요소에 영향을 미치지 않음
		- **O(n)**: 특정 위치에 요소 추가, 특정 값 삭제, 인덱스에 의한 삭제, 요소 탐색, 리스트 복사 - 최악의 경우 최소 한 번은 리스트를 순회함
		- **O(n log n)**: 리스트 정렬 - 정렬 알고리즘별로 시간복잡도가 다르지만 파이썬의 sort함수는 nlogn으로 최적화 되어있음
		- **O(k)**: 슬라이싱 - k는 슬라이스 길이이며, 항상 k개의 객체를 접근해야 함 
## 3. 튜플
- 튜플의 개념과 리스트와의 차이점을 설명해주세요.
	- 가장 큰 차이점은 튜플은 이뮤터블 객체로 수정이 불가능 하다는 점
- 튜플을 사용하는 것이 적합한 경우는 언제인가요?
	- 튜플에 저장된 데이터의 무결성을 확보해야 하는 경우
	- 값의 수정이 발생하지 않는 경우
	- 항상 고정되어 있고 수정이 불가하므로 리스트에 비해 메모리 공간을 효율적으로 사용할 수 있음
	- 값이 고정적이므로 해시가 가능함

## 4. 셋(Set)
- 셋의 개념과 특징을 설명해주세요.
	- 리스트, 튜플과는 달리 순서가 없다.
	- 순서가 없으므로 인덱스도 없다
	- 수정이 가능하다
	- 중복된 값은 저장할 수 없으므로 집합 연산이나, 데이터의 존재유무 확인을 위해 사용함
- 셋(Set)과 리스트의 차이점을 설명해주세요.
	- 중복된 값을 저장할 수 없고
	- 셋에는 순서가 없으므로 인덱싱도 불가능함

## 5. 딕셔너리
- 딕셔너리의 개념에 대해 정리해주세요
	- 순서가 중요하지 않음(파이썬 특정 버전 이후에서는 지원하므로 순서가 없거나 것은 아님)
	- key-value pair로 값을 저장함
	- 수정이 가능
	- key는 중복 불가능함
- 딕셔너리 키로 사용될 수 있는 데이터 타입은 무엇이며, 그 이유는 무엇인가요?
	- 해시 가능한 데이터 타입들을 사용할 수 있음. 문자열, 숫자, 튜플, 불린
	- 해시 가능하려면 변하지 않는 고정된 값이 저장되는 타입이어야 함. 즉, 이뮤터블 객체여야 함.
	- 딕셔너리는 키를 통해 밸류에 접근하므로, 키가 불변해야 항상 일치하는 밸류에 접근할 수 있음
- 딕셔너리에서 키-값 쌍을 삽입, 삭제하는 데 걸리는 시간 복잡도는 무엇인가요?
	- 순서가 중요하지 않으므로 어느 위치에 저장되어도 항상 같다. 따라서 시간복잡도는 O(1)

## 6. 성능 비교 문제
- 리스트에서 `pop(0)`과 `collections.deque.popleft()`의 동작 방식이 어떻게 다르며, 성능 차이가 나는 이유를 설명해주세요.
	- pop(0)은 리스트의 첫 번째 요소를 제거하고, 모든 요소를 한 칸씩 앞으로 가져옵니다. 따라서 최악의 경우 O(n)의 시간복잡도를 가짐
```
class Deque:
	def __init__(self):
		self.head = None
		self.tail = None
		self.length = 0
```
- Deque 클래스는 처음과 끝에 대한 정보를 가지고 있어, 처음과 끝의 값을 넣고 빼는 경우에 최적화 되어있음.
	- 요소의 위치를 이동시키는 것이 아닌, 위치 정보를 변경시키는 것이기 때문
- 중간 인덱스의 요소를 다루는데에는 리스트를 사용하는 것이 효율적이라고 함.


- 리스트와 셋(Set)에서의 데이터 추가 및 삭제의 시간 복잡도를 비교해주세여.
	- 리스트의 데이터 추가/삭제는 최악의 경우 모든 리스트를 순회해야 하므로 O(n)
	- 셋의 데이터 추가/삭제는 순서가 중요하지 않으므로 항상 상수인 O(1)
- 주어진 데이터에서 고유한 값을 찾아야 할 때, 리스트와 셋(Set) 중 어떤 컬렉션을 사용하는 것이 더 효율적인지 설명하고 이유를 서술해주세요.
	- 리스트의 경우 '고유한 값'인지 판단하기 위해서 모든 요소에 대하여 중복 저장 되어있는지 확인하는 연산이 1번씩 발생해야 함. n개의 요소가 모든 요소에 대하여 중복 여부를 확인하면 최악의 경우 n\*n회 연산이 필요하므로 O(n)의 시간복잡도를 가짐
	- 셋은 순서가 중요하지 않으며 중복 데이터를 허용하지 않으므로 모든 요소가 고유하기 때문에 주어진 데이터에서 고유한 값을 찾는다는 상황을 정의할 수 없겠으나, 만약 질문의 의도가 새로운 요소를 추가하는 경우 중복 여부를 확인하는 상황을 가정한다면 항상 요소 갯수만큼 연산이 발생하므로 최악의 경우에도 O(n)
	- 따라서 셋을 사용하는 것이 효율적임
## 7. 리스트 슬라이싱
- 리스트 슬라이싱이란 무엇이며, 슬라이싱을 사용해 리스트의 부분 배열을 얻는 방법을 설명해주세요.
	- 리스트의 특정 범위 인덱스에 해당하는 요소들만을 추출할 수 있음
	- a = [1,2,3,4,5] 에서 b = a[1:3] 과 같이 표기하면 [2,3] 만 추출 가능함

# 코딩 문제

## 문제 1: 리스트의 중복 제거 및 정렬
리스트 `lst`가 주어졌을 때, 리스트 내 중복된 요소를 제거하고 남은 요소들을 오름차순으로 정렬한 새로운 리스트를 반환하는 함수를 작성하세요.

### 답
```python
def remove_duplicates_and_sort(lst):
	return sorted(list(set(lst)))

# 예시
print(remove_duplicates_and_sort([4, 2, 2, 1, 3, 4]))  # 출력: [1, 2, 3, 4]
print(remove_duplicates_and_sort([5, 5, 5, 5]))  # 출력: [5]
print(remove_duplicates_and_sort([1, 2, 3, 4, 5]))  # 출력: [1, 2, 3, 4, 5]
```

## 문제 2: 딕셔너리 키의 빈도수 계산
문자열 리스트 `words`가 주어졌을 때, 각 단어가 리스트에 등장하는 빈도수를 딕셔너리로 반환하는 함수를 작성하세요.

### 답
```python
def count_word_frequencies(words):
	stnds = set(words)
	result = {}
	for word in stnds:
		count = 0
		for i in words:
			if word == i:
				count += 1
	result[word] = count
return result

# 예시
print(count_word_frequencies(["apple", "banana", "apple", "orange", "banana", "apple"]))  
# 출력: {'apple': 3, 'banana': 2, 'orange': 1}
print(count_word_frequencies(["dog", "cat", "dog", "dog", "fish"]))  
# 출력: {'dog': 3, 'cat': 1, 'fish': 1}
```

## 문제 3: 딕셔너리 키 존재 여부 확인
딕셔너리 `d`와 키 `key`가 주어졌을 때, 해당 키가 딕셔너리에 존재하는지 여부를 반환하는 함수를 작성하세요.

### 답
```python
def key_exists(d, key):
	if key in d.keys():
		return True
	return False

# 예시
print(key_exists({"name": "Alice", "age": 25}, "name"))  # 출력: True
print(key_exists({"name": "Alice", "age": 25}, "address"))  # 출력: False
print(key_exists({}, "key"))  # 출력: False
```

## 문제 4: 튜플의 요소 합
튜플 `tpl`이 주어졌을 때, 튜플 내 모든 요소의 합을 반환하는 함수를 작성하세요.

### 답
```python
def sum_of_tuple(tpl):
    return sum(tpl)

# 예시
print(sum_of_tuple((1, 2, 3, 4)))  # 출력: 10
print(sum_of_tuple((5,)))  # 출력: 5
print(sum_of_tuple(()))  # 출력: 0
```

## 문제 5: 리스트 슬라이싱으로 부분 리스트 추출
리스트 `lst`와 두 개의 정수 `start`, `end`가 주어졌을 때, 주어진 범위에 해당하는 부분 리스트를 반환하는 함수를 작성하세요. `start` 인덱스는 포함되며, `end` 인덱스는 포함되지 않습니다.

### 답
```python
def slice_list(lst, start, end):
    return lst[start:end]

# 예시
print(slice_list([10, 20, 30, 40, 50], 1, 3))  # 출력: [20, 30]
print(slice_list([1, 2, 3, 4, 5], 0, 5))  # 출력: [1, 2, 3, 4, 5]
print(slice_list([7, 8, 9], 1, 1))  # 출력: []
```
