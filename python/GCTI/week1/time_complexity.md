시간복잡도 개념 질문
1. 시간복잡도가 무엇인지 정의하고, 왜 알고리즘의 성능을 평가할 때 중요한지 설명하세요.
알고리즘의 성능을 나타내는 지표, input size에 대한 연산횟수의 상한을 의미. 예를 들면 n = 10 의 입력값이 있을 경우에 i,j,k의 nested for loop를 쓰면 아래처럼 알고리즘을 가져가면 n^3 즉 10^3 의 연산횟수를 나타내는데, 만약에 n의 값이 10만개다 하면 100000^3 의 연산을 하게되어 그 시간이 엄청나게 늘어가게 되므로 시스템의 퍼포먼스에 막대한 영향을 끼치게 되므로 최대한 낮은 차수로 알고리즘을 설계하는 것이 중요합니다.

	for i in range(n):
     		for j in range(n):
     			for k in range(n):

2. 빅오 표기법이 무엇인지 설명하고, 알고리즘의 시간복잡도를 표현할 때 빅오 표기법이 사용되는 이유를 설명하세요.
3. 빅오 표기법에서 최악의 경우(worst-case)를 고려하는 이유는 무엇인가요? 실제 상황에서 최악의 경우 시간복잡도가 중요한 이유를 설명하세요.
2-3 Answer: Input data가 100인경우 찾고자 하는 값이 맨앞에 위치한 경우 앞에서부터 순차적으로 알고리즘의 경우 단 1번에 찾을 수도 있고 해당값이 맨 뒤에 있을 수도 있는 경우는 모든 값을 다 검색해서 찾는 경우가 있는데 어떤 형태로 입력값이 주어질 지는 아무도 알 수 없으므로 (worst-case) 임의의 경우를 생각하고 알고리즘을 설계해야 합니다. 그래서 이런 일반적인 임의의 경우를 생각해서 연산횟수의 상한선을 두고 이를 함수로 표현하는 방법이 Big O notation.

4. 빅오 표기법을 사용하여 알고리즘의 효율성을 평가할 때 나타날 수 있는 한계점이나 오해는 무엇인지 설명하세요.
Input data값이  n=5 처럼 아주 작다면 1번 예시처럼 5^3을 해도 뭐 크게 문제가 되지 않지만 n=100만 되어도 n^3, n, logn 의 경우는 아주 큰 차이가 발생합니다.  따라서 알고리즘이 일단 n^3이상 나왔다면 반드시 n^2이하로 줄이는 방법을 우선적으로 고민해 볼 필요가 있습니다. 그러나 무조건 줄이려고 지나치게 시간과 노력을 낭비하기 보다는 책 61페이지에 나와있는 것처럼 시간복잡도와 최대연산횟수 테이블을 참조해서 적절한 알고리즘을 선택하는 것이 큰 무리가 없으리라고 생각됩니다.

시간복잡도 계산 문제
문제1: O(n): for loop를 0부터 n-1까지 한번씩 print 합니다. 
def example_function_1(n):
    for i in range(n):
        print(i)


문제2: O(n^2): 0부터 n-1까지 for loop를 돌때 i번째 각각에 대해 j도 0부터 n-1까지 돌아야 합니다. 그래서 n * n
def example_function_2(n):
    for i in range(n):
        for j in range(n):
            print(i, j)

문제3: O(n): O(n) + O(1): i는 0부터 n-1까지 돌고 j는 0부터 9까지 도는데 j는 constant이므로 dominant한 차수인 n
def example_function_3(n):
    for i in range(n):
        print(i)
    for j in range(10):
        print(j)

문제4:O(2^n): exponential: 피보나치 recusion의 구현으로 현재의 값을 구하기 위해 이전과 전전의 값을 계속해서 더해야 하는 구조로 2의 n승
def fibonacci(n):
    if n <= 1:
        return n
    else:
        return fibonacci(n-1) + fibonacci(n-2)

문제5: O(logn): while loop를 i가 0이 될때까지 한번씩 돌때마다 그 절반씩 줄여서 검색하는 구조이므로 2를 base로 하는 로그 n
def example_function_3(n):
    i = n
    while i > 1:
        i = i // 2
        print(i)
